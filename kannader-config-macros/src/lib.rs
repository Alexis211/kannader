//! Macros that help define communication between a wasm blob and its
//! rust host.
//!
//! All the types are being exchanged bincode-encoded. If multiple
//! parameters are to be taken, they are exchanged as a
//! bincode-encoded tuple.
//!
//! `&mut` references taken as arguments are taken as though they were
//! by value, and then returned as supplementary arguments in a tuple.
//!
//! Note: this crate's guest-side implementation is very heavily tied
//! to the `kannader_config` crate's implementation. This is on
//! purpose and the two crates should be used together. They are split
//! only for technical reasons.

// The functions are all implemented in wasm with:
//
// Parameters: (address, size) of the allocated block containing
// the serialized message. Ownership is passed to the called
// function.
//
// Return: u64 whose upper 32 bits are the size and lower 32 bits
// the address of a block containing the serialized message.
// Ownership is passed to the caller function.

// TODO: this all should be auto-generated by wasm-bindgen, wasm
// interface types, wiggle or similar

use proc_macro::TokenStream;
use proc_macro2::{Ident, Span};
use quote::quote;

const SETUP_FN: fn() -> Function = || Function {
    ffi_name: Ident::new("setup", Span::call_site()),
    fn_name: Ident::new("setup", Span::call_site()),
    args: vec![Argument {
        name: Ident::new("path", Span::call_site()),
        is_mut: false,
        ty: quote!(std::path::PathBuf),
    }],
    ret: quote!(()),
    terminator: quote!(;),
};

#[proc_macro]
pub fn implement_guest(input: TokenStream) -> TokenStream {
    let cfg = syn::parse_macro_input!(input as Ident);
    let ffi_body = run_ffi_fn(
        &SETUP_FN(),
        quote!(std::slice::from_raw_parts(ptr as *const u8, size)),
        quote!(deallocate(ptr, size)),
        |args| {
            quote! {
                KANNADER_CFG.with(|cfg| {
                    assert!(cfg.borrow().is_none());
                    *cfg.borrow_mut() = Some(<#cfg as kannader_config::Config>::setup(#args));
                })
            }
        },
        |size| {
            quote! {{
                assert!(#size == 0, "‘setup’ tried to return a non-empty result");
                (0, (&mut []) as &mut [u8])
            }}
        },
    );
    let res = quote! {
        #[no_mangle]
        pub unsafe extern "C" fn allocate(size: usize) -> usize {
            // TODO: handle alloc error (ie. null return) properly (trap?)
            unsafe {
                std::alloc::alloc(std::alloc::Layout::from_size_align_unchecked(size, 8)) as usize
            }
        }

        #[no_mangle]
        pub unsafe extern "C" fn deallocate(ptr: usize, size: usize) {
            unsafe {
                std::alloc::dealloc(
                    ptr as *mut u8,
                    std::alloc::Layout::from_size_align_unchecked(size, 8),
                )
            }
        }

        std::thread_local! {
            static KANNADER_CFG: std::cell::RefCell<Option<#cfg>> =
                std::cell::RefCell::new(None);
        }

        #[no_mangle]
        pub unsafe extern "C" fn setup(ptr: usize, size: usize) -> u64 {
            #ffi_body
        }

        #[allow(unused)]
        fn DID_YOU_CALL_implement_guest_MACRO() {
            DID_YOU_CALL_server_config_implement_guest_server_MACRO();
        }
    };
    res.into()
}

#[proc_macro]
pub fn implement_host(_input: TokenStream) -> TokenStream {
    let fn_body = call_ffi_fn(
        &SETUP_FN(),
        quote!(memory.data_ptr()),
        quote!(memory.data_size()),
        |s| quote!(allocate(#s)),
        |p, s| quote!(wasm_fun(#p, #s)),
        |_, s| {
            quote! {{
                if #s == 0 {
                    Ok(())
                } else {
                    Err(anyhow::Error::msg("‘setup’ tried to return a non-empty result"))
                }
            }}
        },
    );
    let res = quote! {
        use std::{path::Path, rc::Rc};

        use anyhow::{anyhow, ensure, Context};

        // TODO: take struct name as argument instead of forcing the caller to put in a
        // mod (and same below)
        // TODO: factor code out with the below similar code to serialize the argument
        // TODO: make sure we deallocate the buffers in case any error happens (note
        // however that currently wasm supports only panic=abort which generates a trap,
        // so handling panics in wasm properly must be left for later when this is fixed
        // upstream)
        pub fn setup(
            path: &Path,
            instance: &wasmtime::Instance,
            allocate: Rc<dyn Fn(u32) -> Result<u32, wasmtime::Trap>>,
        ) -> anyhow::Result<()> {
            // Recover memory instance
            let memory = instance
                .get_memory("memory")
                .ok_or_else(|| anyhow!("Failed to find memory export ‘memory’"))?;

            // Recover setup function
            let wasm_fun = instance
                .get_func("setup")
                .ok_or_else(|| anyhow!("Failed to find function export ‘setup’"))?
                .get2()
                .with_context(|| format!("Checking the type of ‘setup’"))?;

            fn force_type<F: Fn(u32, u32) -> Result<u64, wasmtime::Trap>>(_: &F) {}
            force_type(&wasm_fun);

            #fn_body
        }
    };
    res.into()
}

struct Communicator {
    trait_name: Ident,
    link_name: Ident,
    guest_type: Ident,
    funcs: Vec<Function>,
}

struct Function {
    ffi_name: Ident,
    fn_name: Ident,
    args: Vec<Argument>,
    ret: proc_macro2::TokenStream,
    terminator: proc_macro2::TokenStream,
}

struct Argument {
    name: Ident,
    is_mut: bool,
    ty: proc_macro2::TokenStream,
}

#[proc_macro]
pub fn server_config_implement_trait(_input: TokenStream) -> TokenStream {
    make_trait(SERVER_CONFIG())
}

#[proc_macro]
pub fn server_config_implement_guest_server(input: TokenStream) -> TokenStream {
    let impl_name = syn::parse_macro_input!(input as Ident);
    make_guest_server(impl_name, SERVER_CONFIG())
}

#[proc_macro]
pub fn server_config_implement_host_client(input: TokenStream) -> TokenStream {
    let struct_name = syn::parse_macro_input!(input as Ident);
    make_host_client(struct_name, SERVER_CONFIG())
}

fn make_trait(c: Communicator) -> TokenStream {
    let trait_name = c.trait_name;
    let funcs = c.funcs.into_iter().map(|f| {
        let fn_name = f.fn_name;
        let ret = f.ret;
        let terminator = f.terminator;
        let args = f.args.into_iter().map(|Argument { name, is_mut, ty }| {
            if is_mut {
                quote!(#name: &mut #ty)
            } else {
                quote!(#name: #ty)
            }
        });
        quote! {
            #[allow(unused_variables)]
            fn #fn_name(cfg: &Self::Cfg, #(#args),*) -> #ret
                #terminator
        }
    });
    let res = quote! {
        pub trait #trait_name {
            type Cfg: Config;

            #(#funcs)*
        }
    };
    res.into()
}

fn make_guest_server(impl_name: Ident, c: Communicator) -> TokenStream {
    let trait_name = c.trait_name;
    let did_you_call_fn_name = quote::format_ident!(
        "DID_YOU_CALL_{}_implement_{}_MACRO",
        c.link_name,
        c.guest_type
    );
    let funcs = c.funcs.iter().map(|f| -> proc_macro2::TokenStream {
        let ffi_name = &f.ffi_name;
        let fn_name = &f.fn_name;
        let ffi_body = run_ffi_fn(
            &f,
            quote!(std::slice::from_raw_parts(arg_ptr as *const u8, arg_size)),
            quote!(deallocate(arg_ptr, arg_size)),
            |args| {
                quote! {
                    KANNADER_CFG.with(|cfg| {
                        <#impl_name as kannader_config::#trait_name>::#fn_name(
                            cfg.borrow().as_ref().unwrap(),
                            #args
                        )
                    })
                }
            },
            |size| {
                quote! {{
                    let ptr: usize = allocate(#size);
                    let slice = std::slice::from_raw_parts_mut(ptr as *mut u8, #size);
                    (ptr, slice)
                }}
            },
        );
        quote! {
            // TODO: handle errors properly (but what does “properly”
            // exactly mean here? anyway, probably not `.unwrap()` /
            // `assert!`...) (and above in the file too)
            #[no_mangle]
            pub unsafe extern "C" fn #ffi_name(arg_ptr: usize, arg_size: usize) -> u64 {
                #ffi_body
            }
        }
    });
    let res = quote! {
        #(#funcs)*

        #[allow(unused)]
        fn #did_you_call_fn_name() {
            DID_YOU_CALL_implement_guest_MACRO();
        }
    };
    res.into()
}

fn make_host_client(struct_name: Ident, c: Communicator) -> TokenStream {
    let func_defs = c.funcs.iter().map(|f| {
        let fn_name = &f.fn_name;
        let ret = &f.ret;
        let args = f.args.iter().map(|a| {
            let ty = &a.ty;
            if a.is_mut {
                quote!(&mut #ty)
            } else {
                quote!(#ty)
            }
        });
        quote! {
            pub #fn_name: Box<dyn Fn(#(#args),*) -> anyhow::Result<#ret>>,
        }
    });
    let func_gets = c.funcs.iter().map(|f| {
        let fn_name = &f.fn_name;
        let ffi_name_str = format!("{}", f.ffi_name);
        let host_args = f.args.iter().map(|Argument { name, is_mut, ty }| {
            if *is_mut {
                quote!(#name: &mut #ty)
            } else {
                quote!(#name: #ty)
            }
        });
        let failed_to_find_export = format!("Failed to find function export ‘{}’", f.ffi_name);
        let checking_type = format!("Checking the type of ‘{}’", f.ffi_name);
        let fn_body = call_ffi_fn(
            f,
            quote!(memory.data_ptr()),
            quote!(memory.data_size()),
            |s| quote!(allocate(#s)),
            |p, s| quote!(wasm_fun(#p, #s)),
            |p, s| quote!(deallocate(#p, #s)),
        );
        quote! {
            let #fn_name = {
                let memory = memory.clone();
                let allocate = allocate.clone();
                let deallocate = deallocate.clone();

                let wasm_fun = instance
                    .get_func(#ffi_name_str)
                    .ok_or_else(|| anyhow::Error::msg(#failed_to_find_export))?
                    .get2()
                    .context(#checking_type)?;

                fn force_type<F: Fn(u32, u32) -> Result<u64, wasmtime::Trap>>(_: &F) {}
                force_type(&wasm_fun);

                Box::new(move |#(#host_args),*| {
                    #fn_body
                })
            };
        }
    });
    let func_names = c.funcs.iter().map(|f| &f.fn_name);
    let res = quote! {
        pub struct #struct_name {
            #(#func_defs)*
        }

        impl #struct_name {
            pub fn build(
                instance: &wasmtime::Instance,
                allocate: std::rc::Rc<dyn Fn(u32) -> Result<u32, wasmtime::Trap>>,
                deallocate: std::rc::Rc<dyn Fn(u32, u32) -> Result<(), wasmtime::Trap>>,
            ) -> anyhow::Result<Self> {
                use anyhow::{anyhow, ensure, Context};

                let memory = instance
                    .get_memory("memory")
                    .ok_or_else(|| anyhow!("Failed to find memory export ‘memory’"))?;

                #(#func_gets)*

                Ok(Self { #(#func_names),* })
            }
        }
    };
    res.into()
}

fn run_ffi_fn<F, Alloc>(
    f: &Function,
    make_arg_slice: proc_macro2::TokenStream,
    do_dealloc: proc_macro2::TokenStream,
    do_the_thing: F,
    do_alloc: Alloc,
) -> proc_macro2::TokenStream
where
    F: Fn(proc_macro2::TokenStream) -> proc_macro2::TokenStream,
    Alloc: Fn(&Ident) -> proc_macro2::TokenStream,
{
    let deserialize_pat = f.args.iter().map(|Argument { name, is_mut, .. }| {
        if *is_mut {
            quote!(mut #name)
        } else {
            quote!(#name)
        }
    });
    let arguments = f.args.iter().map(|Argument { name, is_mut, .. }| {
        if *is_mut {
            quote!(&mut #name)
        } else {
            quote!(#name)
        }
    });
    let result = f.args.iter().filter_map(
        |Argument { name, is_mut, .. }| {
            if *is_mut { Some(quote!(#name)) } else { None }
        },
    );
    let do_the_thing = do_the_thing(quote!(#(#arguments),*));
    let do_alloc = do_alloc(&Ident::new("ret_size", Span::call_site()));
    quote! {
        // TODO: handle errors properly too (see the TODO down the file)
        // Deserialize from the argument slice
        let ( #(#deserialize_pat),* ) = bincode::deserialize(#make_arg_slice).unwrap();

        // Deallocate the argument slice
        #do_dealloc;

        // Call the callback
        let res = #do_the_thing;
        let res = (res, #(#result),*);

        // Allocate return buffer
        let ret_size: u64 = bincode::serialized_size(&res).unwrap();
        debug_assert!(
            ret_size <= usize::MAX as u64,
            "Message size above usize::MAX, something is really wrong"
        );
        let ret_size: usize = ret_size as usize;
        let (ret_ptr, ret_slice) = #do_alloc;

        // Serialize the result to the return buffer
        bincode::serialize_into(ret_slice, &res).unwrap();

        // We know that usize is u32 thanks to the above const_assert
        ((ret_size as u64) << 32) | (ret_ptr as u64)
    }
}

fn call_ffi_fn<Alloc, F, Dealloc>(
    f: &Function,
    memory_base_ptr: proc_macro2::TokenStream,
    memory_size: proc_macro2::TokenStream,
    allocate: Alloc,
    call_the_fn: F,
    deallocate: Dealloc,
) -> proc_macro2::TokenStream
where
    Alloc: Fn(&Ident) -> proc_macro2::TokenStream,
    F: Fn(&Ident, &Ident) -> proc_macro2::TokenStream,
    Dealloc: Fn(proc_macro2::TokenStream, proc_macro2::TokenStream) -> proc_macro2::TokenStream,
{
    let arg_size_id = Ident::new("arg_size", Span::call_site());
    let arg_ptr_id = Ident::new("arg_ptr", Span::call_site());

    let encode_args = f.args.iter().map(|Argument { name, .. }| quote!(&#name));
    let figuring_out_size_to_allocate_for_arg_buf = format!(
        "Figuring out size to allocate for argument buffer for ‘{}’",
        f.ffi_name
    );
    let allocate_arg_size = allocate(&arg_size_id);
    let allocating_arg_buf = format!("Allocating argument buffer for ‘{}’", f.ffi_name);
    let serializing_arg_buf = format!("Serializing argument buffer for ‘{}’", f.ffi_name);
    let call_the_fn = call_the_fn(&arg_ptr_id, &arg_size_id);
    let running_wasm_func = format!("Running wasm function ‘{}’", f.ffi_name);
    let returned_alloc_outside_of_memory = format!(
        "Wasm function ‘{}’ returned allocation outside of its memory",
        f.ffi_name,
    );
    let deallocating_ret_buf = format!("Deallocating return buffer for function ‘{}’", f.ffi_name);
    let deserializing_ret_msg = format!("Deserializing return message of ‘{}’", f.ffi_name);
    let result_assignment = f.args.iter().filter_map(|a| {
        let name = &a.name;
        if a.is_mut { Some(quote!(*#name)) } else { None }
    });
    let deallocate_res = deallocate(quote!(res_ptr as u32), quote!(res_size as u32));
    quote! {
        // Get the to-be-encoded argument
        let arg = ( #(#encode_args),* );

        // Compute the size of the argument
        let arg_size: u64 = bincode::serialized_size(&arg)
            .context(#figuring_out_size_to_allocate_for_arg_buf)?;
        debug_assert!(
            arg_size <= u32::MAX as u64,
            "Message size above u32::MAX, something is really wrong"
        );
        let arg_size = arg_size as u32;

        // Allocate argument buffer
        let arg_ptr = #allocate_arg_size.context(#allocating_arg_buf)?;
        ensure!(
            (arg_ptr as usize).saturating_add(arg_size as usize) <= #memory_size,
            "Wasm allocator returned allocation outside of its memory"
        );

        // Serialize to argument buffer
        let arg_vec = bincode::serialize(&arg).context(#serializing_arg_buf)?;
        debug_assert_eq!(
            arg_size as usize,
            arg_vec.len(),
            "bincode-computed size is {} but actual size is {}",
            arg_size,
            arg_vec.len()
        );
        // TODO: the volatiles here are actually useless, wasm threads
        // are not a thing and will not be a thing with regular
        // memories
        unsafe {
            std::intrinsics::volatile_copy_nonoverlapping_memory(
                #memory_base_ptr.add(arg_ptr as usize),
                arg_vec.as_ptr(),
                arg_size as usize,
            );
        }

        // Call the function
        let res_u64 = #call_the_fn.context(#running_wasm_func)?;
        let res_ptr = (res_u64 & 0xFFFF_FFFF) as usize;
        let res_size = ((res_u64 >> 32) & 0xFFFF_FFFF) as usize;
        ensure!(
            res_ptr.saturating_add(res_size) <= #memory_size,
            #returned_alloc_outside_of_memory
        );

        // Recover the return slice
        // TODO: the volatiles here are actually useless, wasm threads
        // are not a thing and will not be a thing with regular
        // memories
        let mut res_msg = vec![0; res_size];
        unsafe {
            std::intrinsics::volatile_copy_nonoverlapping_memory(
                res_msg.as_mut_ptr(),
                #memory_base_ptr.add(res_ptr),
                res_size,
            );
        }

        // Deallocate the return slice
        #deallocate_res.context(#deallocating_ret_buf)?;

        // Read the result
        let res;
        (res, #(#result_assignment),*) = bincode::deserialize(&res_msg)
            .context(#deserializing_ret_msg)?;
        Ok(res)
    }
}

macro_rules! communicator {
    (@is_mut ()) => { false };
    (@is_mut (&mut)) => { true };

    (
        communicator $trait_name:ident $link_name:ident $guest_type:ident {
            $(
                $ffi_name:ident => fn
                    $fn_name:ident(&self, $($arg:ident : $mut:tt $ty:ty),* $(,)*) -> ($ret:ty)
                        $terminator:tt
            )+
        }
    ) => {
        || Communicator {
            trait_name: Ident::new(stringify!($trait_name), Span::call_site()),
            link_name: Ident::new(stringify!($link_name), Span::call_site()),
            guest_type: Ident::new(stringify!($guest_type), Span::call_site()),
            funcs: vec![$(
                Function {
                    ffi_name: Ident::new(stringify!($ffi_name), Span::call_site()),
                    fn_name: Ident::new(stringify!($fn_name), Span::call_site()),
                    ret: quote!($ret),
                    args: vec![$(
                        Argument {
                            name: Ident::new(stringify!($arg), Span::call_site()),
                            is_mut: communicator!(@is_mut $mut),
                            ty: quote!($ty),
                        }
                    ),*],
                    terminator: quote!($terminator),
                }
            ),+],
        }
    };
}

static SERVER_CONFIG: fn() -> Communicator = communicator! {
    communicator ServerConfig server_config guest_server {
        server_config_welcome_banner_reply => fn welcome_banner_reply(
            &self,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_message::Reply) ;

        server_config_filter_hello => fn filter_hello(
            &self,
            is_ehlo: () bool,
            hostname: () smtp_message::Hostname,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_server_types::SerializableDecision<smtp_server_types::HelloInfo>) ;

        server_config_can_do_tls => fn can_do_tls(
            &self,
            conn_meta: () smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (bool)
        {
            !conn_meta.is_encrypted &&
                conn_meta.hello.as_ref().map(|h| h.is_ehlo).unwrap_or(false)
        }

        server_config_new_mail => fn new_mail(
            &self,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (Vec<u8>) ;

        server_config_filter_from => fn filter_from(
            &self,
            from: () Option<smtp_message::Email>,
            meta: (&mut) smtp_server_types::MailMetadata<Vec<u8>>,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_server_types::SerializableDecision<Option<smtp_message::Email>>) ;

        server_config_filter_to => fn filter_to(
            &self,
            to: () smtp_message::Email,
            meta: (&mut) smtp_server_types::MailMetadata<Vec<u8>>,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_server_types::SerializableDecision<smtp_message::Email>) ;

        server_config_filter_data => fn filter_data(
            &self,
            meta: (&mut) smtp_server_types::MailMetadata<Vec<u8>>,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_server_types::SerializableDecision<()>)
        {
            smtp_server_types::SerializableDecision::Accept {
                reply: smtp_server_types::reply::okay_data().convert(),
                res: (),
            }
        }

        server_config_handle_rset => fn handle_rset(
            &self,
            meta: (&mut) Option<smtp_server_types::MailMetadata<Vec<u8>>>,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_server_types::SerializableDecision<()>)
        {
            smtp_server_types::SerializableDecision::Accept {
                reply: smtp_server_types::reply::okay_rset().convert(),
                res: (),
            }
        }

        server_config_handle_starttls => fn handle_starttls(
            &self,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_server_types::SerializableDecision<()>)
        {
            if Self::can_do_tls(cfg, (*conn_meta).clone()) {
                smtp_server_types::SerializableDecision::Accept {
                    reply: smtp_server_types::reply::okay_starttls().convert(),
                    res: (),
                }
            } else {
                smtp_server_types::SerializableDecision::Reject {
                    reply: smtp_server_types::reply::command_not_supported().convert(),
                }
            }
        }

        server_config_handle_expn => fn handle_expn(
            &self,
            name: () smtp_message::MaybeUtf8<String>,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_server_types::SerializableDecision<()>)
        {
            smtp_server_types::SerializableDecision::Reject {
                reply: smtp_server_types::reply::command_unimplemented().convert(),
            }
        }

        server_config_handle_vrfy => fn handle_vrfy(
            &self,
            name: () smtp_message::MaybeUtf8<String>,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_server_types::SerializableDecision<()>)
        {
            smtp_server_types::SerializableDecision::Accept {
                reply: smtp_server_types::reply::ignore_vrfy().convert(),
                res: (),
            }
        }

        server_config_handle_help => fn handle_help(
            &self,
            subject: () smtp_message::MaybeUtf8<String>,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_server_types::SerializableDecision<()>)
        {
            smtp_server_types::SerializableDecision::Accept {
                reply: smtp_server_types::reply::ignore_help().convert(),
                res: (),
            }
        }

        server_config_handle_noop => fn handle_noop(
            &self,
            string: () smtp_message::MaybeUtf8<String>,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_server_types::SerializableDecision<()>)
        {
            smtp_server_types::SerializableDecision::Accept {
                reply: smtp_server_types::reply::okay_noop().convert(),
                res: (),
            }
        }

        server_config_handle_quit => fn handle_quit(
            &self,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_server_types::SerializableDecision<()>)
        {
            smtp_server_types::SerializableDecision::Kill {
                reply: Some(smtp_server_types::reply::okay_quit().convert()),
                res: Ok(()),
            }
        }

        server_config_already_did_hello => fn already_did_hello(
            &self,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_message::Reply)
        {
            smtp_server_types::reply::bad_sequence().convert()
        }

        server_config_mail_before_hello => fn mail_before_hello(
            &self,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_message::Reply)
        {
            smtp_server_types::reply::bad_sequence().convert()
        }

        server_config_already_in_mail => fn already_in_mail(
            &self,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_message::Reply)
        {
            smtp_server_types::reply::bad_sequence().convert()
        }

        server_config_rcpt_before_mail => fn rcpt_before_mail(
            &self,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_message::Reply)
        {
            smtp_server_types::reply::bad_sequence().convert()
        }

        server_config_data_before_rcpt => fn data_before_rcpt(
            &self,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_message::Reply)
        {
            smtp_server_types::reply::bad_sequence().convert()
        }

        server_config_data_before_mail => fn data_before_mail(
            &self,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_message::Reply)
        {
            smtp_server_types::reply::bad_sequence().convert()
        }

        server_config_starttls_unsupported => fn starttls_unsupported(
            &self,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_message::Reply)
        {
            smtp_server_types::reply::command_not_supported().convert()
        }

        server_config_command_unrecognized => fn command_unrecognized(
            &self,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_message::Reply)
        {
            smtp_server_types::reply::command_unrecognized().convert()
        }

        server_config_pipeline_forbidden_after_starttls => fn pipeline_forbidden_after_starttls(
            &self,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_message::Reply)
        {
            smtp_server_types::reply::pipeline_forbidden_after_starttls().convert()
        }

        server_config_line_too_long => fn line_too_long(
            &self,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_message::Reply)
        {
            smtp_server_types::reply::line_too_long().convert()
        }

        server_config_handle_mail_did_not_call_complete => fn handle_mail_did_not_call_complete(
            &self,
            conn_meta: (&mut) smtp_server_types::ConnectionMetadata<Vec<u8>>,
        ) -> (smtp_message::Reply)
        {
            smtp_server_types::reply::handle_mail_did_not_call_complete().convert()
        }

        server_config_reply_write_timeout_in_millis => fn reply_write_timeout_in_millis(
            &self,
        ) -> (u64)
        {
            // 5 minutes in milliseconds
            5 * 60 * 1000
        }

        server_config_command_read_timeout_in_millis => fn command_read_timeout_in_millis(
            &self,
        ) -> (u64)
        {
            // 5 minutes in milliseconds
            5 * 60 * 1000
        }
    }
};
